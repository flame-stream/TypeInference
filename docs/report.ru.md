# Типы и их население как способ задания и оптимизации вычислительных графов

## Введение

### Вычислительные графы

TODO Кто такие, зачем нужны, фраемворки всякие.

Будем рассматривать вычислительные графы в форме ориентированных графов без циклов (DAG) с одним стоком.

### Существующие способы задания вычислительных графов

TODO

![flink's](https://flink.apache.org/img/api-stack.png)

### Недостатки существующих способов задания вычислительных графов

TODO Либо конкретный, либо сиквел, который часто не катит.

TODO Пример где сиквел не катит будет ниже, почему не катит.


## Идея

Когда мы задаём вычислительный граф с помощью существующего API, отличного от SQL, мы однозначно определяем порядок операций (топологию графа), из которого следует его семантика: какие должны быть результаты вычисления, и куда они должны попасть.
Одну семантику могут задавать несколько разных топологий, которые отличаются эффективностью вычислений.
Таким образом, если задавать сразу семантику, то, может быть, удасться получить все топологии, её задающие, чтобы из этого набора выбрать самую эффективную.

Будем задавать семантику как пару из набора операций с их контрактами (какие данные и с какими свойствами операция должна получать и отдавать) и описания результата вычислений.

TODO а нужно ли нам описание результата, когда можно вставить операцию, принимающую тип результата и возвращающую ничего.

Так, перебирая все комбинации операций, и проверяя их контракты, мы получим набор всех допустимых топологий.
Но пространство перебора растёт как факториал от числа операций.
Таким образом, необходимо его ограничивать.

Построим биекцию между графами и термами лямбда-исчисления: потокам будут соответствовать константы, операциям - функции. (Граф = дерево абстрактного синтаксиса терма)

Идея: если выбрать типизацию лямбда-исчисления такую, что она будет ограничивать пространство поиска и отражать контракты потоков и операций, то наша задача сведётся к задаче населения типов, которую, может быть, удасться решать быстрее.

### Вид реализации и целевой API

Реализация должна быть представлена в виде библиотеки, которая по набору операций и потоков, аннотированных контрактами, и реализованных с помощью некоторого целевого API, строит все термы, удовлетворяющие контрактам, выбирает из них самый оптимальный в соответствии с некоторой кост-моделью, по которому строит граф в целевом API.

Поскольку должна быть возможность переставлять операции, целевое API должно быть к языку программирования с динамической типизацией.

Возьмём Apache Beam API for Python.

TODO проверить, что можно так задать кусочки графа, их в рантайме переставить и отдать фраемворку

TODO кто такой Apache Beam, описание

### Общее описание контрактов

У операций определяется два контракта: на входные данные и выходные. У потоков - один, выходной.

Во входном контракте требуется описать: набор атрибутов данных, требуемые свойства атрибутов и связей между ними, запрещённые свойства.

В выходном контракте: набор атрибутов данных, устанавливаемые свойства, отменяемые свойства.

Поскольку Apache Beam API for Python выбрано целевым, достаточно научиться записывать контракты для каждой из ключевых операций:
- ParDo
- GroupByKey
- CoGroupByKey
- Combine
- Flatten
- Partition

Таким образом, контракт потока можно записать например так:
```
// Поток записей о питомцах с идентификатором, именем и возрастом.
// Возраст всех питомцев в потоке меньше 10ти лет.
pets : { pet.id; pet.name; pet.age | +less10 }
```

Контракт операции может быть записан так:
TODO
```
CoGroupByKey : {}
             , {}
            -> {}
```

### Подход к реализации

Чем лучше выбранная система типов отражает контракты, тем больше возможностей переставлять операции и получать новые термы, но тем менее вероятно, что удасться найти алгоритм, который эффективно будет перебирать термы, адекватные задаче.

Таким образом, будем пробовать разные подходы к типизации и исследовать:
- Возможность получения различных термов по типовой записи
- Эффективность алгоритма населения


## Пример

### Требования к примеру

- Наличие всех базовых операций Apache Beam
- Наличие всех кейсов для оптимизации (TODO см через неделю раздел про оптимизации)

### Граф

TODO

### Оптимизированный граф

TODO


## Термы

TODO терм к примеру

TODO техническая проблема - введение уровня косвенности


## Системы типов

Пробуем типизировать фрагменты графа из примера и их переставлять

Основаная идея в том, чтобы приписать контакту тип. Самая простая система типов - это 
просто типизированное люямбда исчисление. Далее будет показано почему нам она не подходит и 
почему не подходят более сложные системы типов.  


### Просто типизированное $\lambda$-исчисление

Тут будет рассмотрен подход, когда каждому контакту сопостовляется простой тип. 
Для начала определим правила вывода типов. 

#### Правила вывода:

```
       x:a -> G
(I)   ----------
       G |- x:a 

       G |- e : a -> b  G |- x : a
(E->) ------------------------------
              G |- e x : b

       G |- e : b   G |- x : a
(I->) -------------------------
        G |- \x -> e : a -> b
```

#### Достоинства:

 - Существует алгоритм населения типов
 - ?

#### Недостатки:
 - Не обладает достаточной выразительностью для описания сложных графов вычислений.
 - Нельзя переиспользовать термы для разных источников данных, 
 т.к. источники разныех типов, хотя семнатика их данных может быть очень похожа. 


### Лямбда с аркой $\lambda \cap$

Это расширение простого лямбда исчисления, которое позоваляет избавиться от некоторых его недостатков
описанных выше.  

#### Правила вывода:
Они тут те же что и обычном лямбда исчислении плюс несколько новых. 
Знак ```<``` ниже будет использоваться как отношение "вхождения" типов друг в друга:

```
a < a
a∩b < a
a∩b < b
c < a && c < b => c < a∩b
a < b && b < c => a < c  
```

Там был загадачный тип ```w``` он выполняет роль наиболее общего типа:

```
a < w
w < (a -> w)

(a -> b) ∩ (a -> c) < a -> (b∩c)
a < a' && b < b'
(a -> b) < (a' -> b')

```

Теперь сами правила вывода:


```
       x:a -> G
(I)   ----------
       G |- x:a 

       G |- e : a -> b  G |- x : a
(E->) ------------------------------
             G |- e x : b

       G |- e : b   G |- x : a
(I->) --------------------------
         G |- \x -> e : a -> b


       G |- M : a    G |- M : b    
(I∩)  --------------------------
            G |- M : a∩b

       G |- M:a
(<)   ----------   a < b
       G |- M:b
      
(w)    G |- x:w

```


#### Subtyping

Если присмотреться к этой системе типов немного внимательнее, 
то окажется, что это очень похоже на модель множетсвенного наследования в объектно ориентированных 
языках вроде Java или Python. ```w``` выполняет роль некоторого общего типа Object, а пересечение - 
наследование от каких-то произвольных типов. 

#### Достоинства 
 - Позволяет переиспользовать термы для разных источников
 - Задача населения типов "semi-решаема"
 
#### Недостатки
 - До сих пор не обладает дотстаточной выразительностью
 - ?
 
 
### Более сложные системы типов

 - Слишком сложные :)
 - Задача населения неразрешима 

### Менее строгая система, а потом проверка контрактов ручками или через Z3

Добавим к выбранной системе типов возможность аннтирования типов предикатами. А потом будем
их проверять. Это разделит задачу генерации графов исполнения на две подзадачи:
 1. Население желаемого типа. Тут выбранная система типов будет ограничивать свободу перебора
 и защищать от комбинаторного вызрыва. 
 2. Проверка аннтоаций на выполнение с помощью SAT-solver'а.  

Но тут есть некоторая проблема:

 ```
G = { f :: a -> b, x :: a { x:a | Q(x) } }

G |- f x :: b { y:b | P(y) }, где P = ??
 
```    

Возможно она решается как-то так:
```
G = { f :: a -> b, x :: a { x:a | Q(x) } }

G |- f x :: b { y:b | P(y) }, где P(y) = ( y = f x && Q(x) )

```

## Функция оценки

- Фильтры
- Решардирования

TODO


## Реализация прототипа на хаскеле

TODO


## Боевая реализация на питоне

TODO


## Выводы

TODO
