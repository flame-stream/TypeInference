# Типы и их население как способ задания и оптимизации вычислительных графов

## Введение

### Вычислительные графы

TODO Кто такие, зачем нужны, фраемворки всякие.

Будем рассматривать вычислительные графы в форме ориентированных графов без циклов (DAG) с одним стоком.

### Существующие способы задания вычислительных графов

TODO

![flink's](https://flink.apache.org/img/api-stack.png)

### Недостатки существующих способов задания вычислительных графов

TODO Либо конкретный, либо сиквел, который часто не катит.

TODO Пример где сиквел не катит будет ниже, почему не катит.


## Идея

Когда мы задаём вычислительный граф с помощью существующего API, отличного от SQL, мы однозначно определяем порядок операций (топологию графа), из которого следует его семантика: какие должны быть результаты вычисления, и куда они должны попасть.
Одну семантику могут задавать несколько разных топологий, которые отличаются эффективностью вычислений.
Таким образом, если задавать сразу семантику, то, может быть, удасться получить все топологии, её задающие, чтобы из этого набора выбрать самую эффективную.

Будем задавать семантику как пару из набора операций с их контрактами (какие данные и с какими свойствами операция должна получать и отдавать) и описания результата вычислений.

TODO а нужно ли нам описание результата, когда можно вставить операцию, принимающую тип результата и возвращающую ничего.

Так, перебирая все комбинации операций, и проверяя их контракты, мы получим набор всех допустимых топологий.
Но пространство перебора растёт как факториал от числа операций.
Таким образом, необходимо его ограничивать.

Построим биекцию между графами и термами лямбда-исчисления: потокам будут соответствовать константы, операциям - функции. (Граф = дерево абстрактного синтаксиса терма)

Идея: если выбрать типизацию лямбда-исчисления такую, что она будет ограничивать пространство поиска и отражать контракты потоков и операций, то наша задача сведётся к задаче населения типов, которую, может быть, удасться решать быстрее.

### Вид реализации и целевой API

Реализация должна быть представлена в виде библиотеки, которая по набору операций и потоков, аннотированных контрактами, и реализованных с помощью некоторого целевого API, строит все термы, удовлетворяющие контрактам, выбирает из них самый оптимальный в соответствии с некоторой кост-моделью, по которому строит граф в целевом API.

Поскольку должна быть возможность переставлять операции, целевое API должно быть к языку программирования с динамической типизацией.

Возьмём Apache Beam API for Python.

TODO проверить, что можно так задать кусочки графа, их в рантайме переставить и отдать фраемворку

TODO кто такой Apache Beam, описание

### Общее описание контрактов

У операций определяется два контракта: на входные данные и выходные. У потоков - один, выходной.

Во входном контракте требуется описать: набор атрибутов данных, требуемые свойства атрибутов и связей между ними, запрещённые свойства.

В выходном контракте: набор атрибутов данных, устанавливаемые свойства, отменяемые свойства.

Поскольку Apache Beam API for Python выбрано целевым, достаточно научиться записывать контракты для каждой из ключевых операций:
- ParDo
- GroupByKey
- CoGroupByKey
- Combine
- Flatten
- Partition

Таким образом, контракт потока можно записать например так:
```
// Поток записей о питомцах с идентификатором, именем и возрастом.
// Возраст всех питомцев в потоке меньше 10ти лет.
pets : { pet.id; pet.name; pet.age | +less10 }
```

Контракт операции может быть записан так:
TODO
```
CoGroupByKey : {}
             , {}
            -> {}
```

### Подход к реализации

Чем лучше выбранная система типов отражает контракты, тем больше возможностей переставлять операции и получать новые термы, но тем менее вероятно, что удасться найти алгоритм, который эффективно будет перебирать термы, адекватные задаче.

Таким образом, будем пробовать разные подходы к типизации и исследовать:
- Возможность получения различных термов по типовой записи
- Эффективность алгоритма населения


## Пример

### Требования к примеру

- Наличие всех базовых операций Apache Beam
- Наличие всех кейсов для оптимизации (TODO см через неделю раздел про оптимизации)

### Граф

TODO

### Оптимизированный граф

TODO


## Термы

TODO терм к примеру

TODO техническая проблема - введение уровня косвенности


## Типы

Пробуем типизировать фрагменты графа из примера и их переставлять

### Просто типизированное не катит

TODO

### Лямбда с аркой

TODO

### Subtyping

TODO

### Менее строгая система, а потом проверка контрактов ручками или через Z3

TODO

### Просто типизированное $\lambda$-исчисление

Чтобы переставить местами две функции, требуется, чтобы они были эндоморфизмами.
Из двух типов можно лишь понять, равны ли они.

TODO пруф: не катит


## Функция оценки

- Фильтры
- Решардирования

TODO


## Реализация прототипа на хаскеле

TODO


## Боевая реализация на питоне

TODO


## Выводы

TODO
